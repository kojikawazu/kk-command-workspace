# Java 8からJava 22までの主な新機能と改善点まとめ

※ ChatGPTのDeep Search使用。
※ TODO: Java23が未対応。

## Java 8 (2014年3月, LTS)

- ラムダ式とStream APIの導入
  - 匿名関数であるラムダ式により、コレクションの要素操作を関数型スタイルで記述できるようになりました​。forループなど従来の手続きを簡潔化し、mapやfilterといったストリーム操作でデータの変換・集計処理が可能です​。例えば次のようにリストをソートして収集できます:

```java
List<String> names = Arrays.asList("Tom", "Bob", "Alice");
names.forEach(name -> System.out.println(name));           // ラムダ式で要素を出力
List<String> sorted = names.stream()
                           .sorted()
                           .collect(Collectors.toList());  // ストリームでソートして収集
```

- インターフェースのデフォルトメソッド
  – インターフェースにメソッド実装を追加できるようになり、既存クラスに影響を与えずAPI拡張が可能となりました​。これにより、インターフェースの後方互換性を保ちながらメソッドを追加できます。

- 新しい日付と時間API (java.time)
  – 従来のDate/Calendarに代わり、型安全で操作性の高い日時APIが追加されました​。例えばLocalDateやDateTimeFormatterにより日時の扱いが簡潔になり、従来のクラスの問題点（可変性やタイムゾーン計算の複雑さ）を解消しています。

- Optionalクラス
  - 値の有無を表現するコンテナ型Optional<T>が追加され、nullチェックの簡略化とNullPointerExceptionの防止に役立ちます​。例えばOptional.ofNullable(obj)でnullかもしれない値をラップし、ifPresentで中身がある場合のみ処理するといったパターンが利用できます。

- 並行処理向け新API
  – 非同期計算を扱うCompletableFutureや、並列処理フレームワークであるFork/Joinプールの改善など、マルチスレッド開発を支えるライブラリが強化されました。また、コレクションAPIにもスレッドセーフな計数用マップLongAdderなどユーティリティが追加されています。

- JavaScriptエンジン「Nashorn」
  – Java上でJavaScriptを実行できる新しい軽量エンジンが搭載されました​（後のバージョンで廃止予定）。これによりJavaアプリケーション内にJavaScriptコードを組み込んで実行できます。

- アノテーション機能の拡張
  – 型にアノテーションを付与できるようになり（例：List<@NonNull String>）​、また同じアノテーションを複数回適用できる「リピート可能アノテーション」が導入されました​。これにより、より表現力豊かなメタデータ定義が可能です。

- Permanent Generationの廃止
  – ヒープ領域のPermanent Generation（PermGen）が削除され、代わりにMetaspaceが導入されました​。これにより、PermGen不足によるエラーが解消し、自動メモリ管理が向上しています。

## Java 9 (2017年9月)

- Javaモジュールシステム（JPMS）の導入
  – プロジェクト「Jigsaw」によりJDK自体がモジュール化され、module-info.javaによってクラスのカプセル化と依存関係管理が強化されました​。不要なモジュールを除外して小さなランタイムイメージを作成でき、アプリケーションの構造化やセキュリティが向上しています​。

- JShell（REPL）の追加
  – 対話式読み-eval-プリントループ環境であるJShellが提供され、Javaコードを対話的に実行・検証できるようになりました​。例えばjshell起動後にSystem.out.println("Hello");と入力すると即座に結果を得られ、学習やプロトタイピングが容易になります。

- コレクションのファクトリメソッド
  – コレクションAPIにList.of(...)やSet.of(...)など少数要素の不変コレクションを簡易生成するための静的メソッドが追加されました​。ボイラープレートを削減し、生成されるコレクションは不変であるため安全性も向上します（例：List<String> names = List.of("Alice", "Bob");）。

- Stream APIの拡張
  – ストリームに対して要素を条件で取り出すtakeWhile/dropWhileや反復生成するiterateメソッドが追加されました​。例えばstream.takeWhile(x -> x < 5)で条件を満たす間だけ要素を処理でき、ストリーム処理の表現力が高まっています。

- 言語の細かな改善 (Project Coin)
  – インターフェースにprivateメソッドを定義可能になり、デフォルトメソッド間で共通コードを共有できるようになりました​。また、try-with-resources文で事前に確保したリソース変数をそのまま利用できるよう拡張され、匿名クラスでのダイヤモンド演算子<>利用や、単一アンダースコア_の識別子としての使用禁止（将来のキーワード予約のため）など、いくつかの構文強化が行われています​。

- 新しいAPIとツール: 
  - 低レベル並行処理向けにVarHandle（sun.misc.Unsafe相当の機能を安全に提供）や、Reactive Streams仕様に基づくFlow API（Publish-Subscribeモデル実装）が追加されました​。また、マルチリリースJARに対応し、JAR内にJava 9用クラスを含めてバージョン毎に挙動を変えることが可能になっています。さらに、jlinkツールが追加され、必要なモジュールだけを組み込んだカスタムJREイメージを作成できます​。

- Ahead-of-Timeコンパイル (実験的)
  – クラスを事前コンパイルしてネイティブコード化するjaotcツールが導入されました​。GraalVMにより提供される実験機能で、特定のアプリケーションで起動時間の短縮などが期待できます。

- 削除・非推奨: 
  - JavaDB (Java内蔵のデータベース)がJDKから削除されました​。また、Java AppletやJava Web Startは将来的な削除を見据えて非推奨となり（実際の削除は後述のJava 11で実施）、JDK内部APIへのアクセスもモジュールシステムにより原則禁止されるようになりました。

## Java 10 (2018年3月)

- ローカル変数型推論（var）
  – ローカル変数宣言時に型を明示せずvarキーワードを使うことで、コンパイラが型を推論する機能が追加されました​。例えばvar list = new ArrayList<String>();と記述すれば、コンパイラがlistをArrayList<String>型と判断します。これにより型名の重複記述が減り、コードが簡潔になります。

- 内部のパフォーマンス改善:
  - デフォルトGCのG1においてフルGCの並列化が行われ、GC停止時間が短縮されました​。また、**アプリケーション・クラスデータ共有（AppCDS）がデフォルト有効化され、複数Javaプロセス間でクラスメタデータを共有してメモリ節約と起動時間短縮が図られています​。さらに、実験的なJava版JITコンパイラ(Graal)**が搭載され、オプションで使用可能になりました​。OpenJDKビルドにはあらかじめ主要なルート証明書が同梱されるようになり​、商用JDKとの差異が縮小しています。

- ツールとその他の変更:
  - Javaヘッダファイル生成ツールのjavahが不要になり、廃止されました​（JNIヘッダはjavacが自動生成）。バージョン表記も変更され、従来の「Java 10」ではなく**「18.3」(Year.Quarter)** のように年と月を含むフォーマットに移行しています​（一般的には引き続きJava 10と呼称）。

## Java 11 (2018年9月, LTS)

- 長期サポート(LTS)版としてのリリース
  – Java 8以来のLTSとなるバージョンで、以降3年毎にLTS版が提供されます​。Java 11ではOracle JDKとオープンソースのOpenJDKの機能差がほぼ無くなり、商用サポートとコミュニティサポートの二軌道が明確化しました。

- HTTPクライアントAPIの標準化
  – HTTP/2対応の新しいjava.net.http.HttpClientが正式に組み込まれました​。これにより、従来のHttpURLConnectionや外部ライブラリに頼らずに非同期なHTTP通信やWebSocket通信が可能です。例えば簡単にGETリクエストを発行してレスポンスボディを取得できます。

- フライトレコーダ (JDK Flight Recorder) の統合
  – もともと商用機能だった軽量プロファイラがオープンソース化され、JDKに統合されました​。実行中のJVMから低オーバーヘッドで詳細なイベントログを取得でき、性能分析やトラブルシューティングに役立ちます。

- TLS 1.3 と最新暗号のサポート
  – セキュリティ面ではTLS 1.3がデフォルト有効となり、より安全な通信が行えるようになりました​。また、ChaCha20-Poly1305といった高速な暗号アルゴリズムが追加され、暗号スイートが強化されています​。

- 新ガベージコレクタの導入
  – 極端に停止時間を短縮する実験的GC「ZGC」が追加されました​。最大数ミリ秒のポーズで大容量ヒープを扱えるのが特長です（※デフォルトでは非使用）。さらにEpsilon GCと呼ばれるno-op GC（ヒープが一杯になるまでガベージコレクションを行わない）が実験的に導入され、GC動作の検証用途などに使われます​。

- 便利機能の追加:
  - javaコマンドで単一のソースファイルを直接実行できるようになりました​。例えばHello.javaを作成したら、コンパイルせずにjava Hello.javaと実行可能です（内部で自動的にコンパイルされ実行される）​。スクリプト的な利用や簡易な動作確認が容易になります。

- その他の改善:
  - ネストした内部クラス間のアクセスチェックを簡略化するNest-Based Access Controlが導入され、コンパイラが生成するブリッジメソッドが削減されました​。Unicode 10への対応や、varをラムダ式の仮引数型として使用可能にする拡張も盛り込まれています。

- 非推奨と削除: 
  - Java 11では古い技術が多数整理されました。まず、Java AppletおよびJava Web Startが完全に削除されました​。さらに、JDKに同梱されていたJavaFXも削除され、今後は別途ライブラリとして提供されています​。長らく非推奨だったJava EE（JAX-WS,JAXBなど）およびCORBAモジュールもJDKから取り除かれました​。加えて、JavaScriptエンジンNashornと圧縮JAR機能Pack200が非推奨となり​、将来の削除が予告されています。

## Java 12 (2019年3月)

- switch式（プレビュー）
  – switchを従来の文だけでなく式として使用できるようになるプレビュー機能が追加されました​。矢印構文(->)で分岐ごとに値を返し、複数ケースをコンマで区切ってまとめることができます（break不要）。複雑な計算にはyield文で値を返すことも可能です​。この機能により、従来の煩雑なswitch文を簡潔に記述でき、条件分岐を式として扱えるようになります。例えば月から日数を求める処理が簡潔に書けます:

```java
// Java 12以降（プレビュー機能の有効化が必要）
int days = switch (month) {
    case 1, 3, 5, 7, 8, 10, 12 -> 31;
    case 4, 6, 9, 11 -> 30;
    case 2 -> {
        if (year % 400 == 0) yield 29;
        else if (year % 100 == 0) yield 28;
        else if (year % 4 == 0) yield 29;
        else yield 28;
    }
    default -> throw new IllegalArgumentException("無効な月");
};
```

- Shenandoah GCの追加
  – 低遅延志向の新GC「Shenandoah」が実験的に導入されました​。並行マーク＆コンパクトによってGCポーズを短縮するRedHat発のGCで、大規模ヒープでも応答性を改善できます（Linux版のHotSpotに搭載）。

- G1 GCの改良
  – G1ガベージコレクタにおいて、混合GC処理の中断（Abortable Mixed Collections）と未使用メモリの迅速な解放（Idle時にヒープをOSに返す機能）が実装されました​。これにより、メモリ使用量のピーク後に未使用領域をシステムに返却でき、効率的なメモリ管理が可能です。

- JVM改善:
  - クラスファイル内定数を扱うJVM定数APIが追加され、バイトコード操作ライブラリの将来互換性が向上しました​。また、マイクロベンチマーク用のテストスイート（JEP 230）が内蔵され、JDK自身の性能評価に役立てられています​。(Java 12は比較的小規模なアップデートで、大部分の新機能はプレビュー段階でした。)

## Java 13 (2019年9月)

- テキストブロック（プレビュー）
  – 複数行の文字列リテラルを簡潔に表現できるテキストブロック機能が追加されました​。三連の引用符(""")で囲むことで改行やインデントを含む文字列をコード中にそのまま記述できます。例えばHTMLやSQLの埋め込み文字列が可読性高く記述可能です（Java 15で正式化）。

- switch式（再プレビュー）
  – Java 12で導入されたswitch式が改良され、再度プレビュー公開されました​。矢印->構文などに微調整が加えられ、将来の正式化に向けたフィードバック反映が行われています。

- ソケットAPIの再実装
  – 従来からあるブロッキングIO用ソケット実装が内部的に新しい実装に置き換えられました​。これによりメンテナンス性やパフォーマンスが向上しています（機能的な変更はありません）。

- 動的CDSアーカイブ
  – クラスデータ共有（CDS）の機能強化として、動的クラスアーカイブが導入されました​。実行時に最適化されたクラスリストをアーカイブ化し、次回起動以降のクラスローディングを高速化できます。

- ZGCの改良
  – ZGCにおいて未使用メモリをOSに返却する機能が追加され、アプリケーションのメモリフットプリント縮小に寄与します​。(Java 13もプレビュー中心のリリースです。主要機能の正式化は次のJava 14以降に持ち越されました。)

## Java 14 (2020年3月)

- switch式の正式化
  – 前リリースまでプレビューだったswitch式が正式リリースされました​。case ->による簡潔な記述とyieldによる値の返却が標準機能となり、従来より明確で安全なスイッチ処理が書けます。

- レコード型（プレビュー）
  – Javaにおけるデータキャリア用の新しい型であるレコードがプレビュー導入されました​。recordキーワードでクラスを定義すると、equals/hashCode/toStringや不変のフィールドなどボイラープレートを自動生成できます​。シンプルな値オブジェクトを簡潔に表現できる機能です。

- instanceofパターンマッチ（プレビュー）
  – オブジェクトが特定の型の場合に、その型にキャストした変数を直接扱える構文が追加されました​。例えばif (obj instanceof String s)と書くと、ブロック内でキャスト済みの変数sを利用できます。明示的なキャストが不要になり、コードを簡潔かつ安全にできます。

```java
Object obj = "hello";
if (obj instanceof String s) {
    // s は objをString型にキャストしたもの
    System.out.println(s.length());  // Stringの場合のみ実行
}
```

- テキストブロック（再プレビュー）
  – テキストブロック機能が引き続きプレビュー提供され、細かな改善が施されました​。最終調整を経てJava 15で正式リリースされます。

- NullPointerExceptionメッセージの強化
  – デバッグ支援のため、ヌルポインタ例外発生時に「どの変数がnullだったか」を示す詳細メッセージが有効化されました​。スタックトレースだけでなく原因変数名を出力することで、問題箇所の特定が容易になります。

- jpackageツール（試験的）
  – Javaアプリケーションをネイティブインストーラ形式（msi, pkg, deb等）でパッケージングするツールが試験提供されました​。GUIアプリの配布などで従来必要だったサードパーティ製ツールに替わり、公式にバンドル可能です（Java 16で正式化）。

- その他の改善:
  - G1 GCがNUMAアーキテクチャを考慮したメモリアロケーションを行うようになり（JEP 345）、JFR（Java Flight Recorder）のイベントストリーミングAPIが追加されました​。また、CMS GCの完全削除​、ZGCのWindowsおよびMac対応​、Solaris/SPARCサポートの非推奨化​など、プラットフォームサポートの見直しが行われています。

## Java 15 (2020年9月)

- テキストブロックの正式対応
  – 複数行文字列リテラルであるテキストブロックがプレビューを経て正式機能になりました​。これにより、改行や特殊文字を含む文字列を直感的に記述でき、文字列操作の可読性が向上しています。

- シールドクラス（sealed classes, プレビュー）
  – クラスまたはインターフェースに継承や実装を許可する型を制限できるシールドクラス機能が導入されました​。sealed修飾子とpermits節で継承を許可するサブタイプを列挙し、許可された型以外が継承するとコンパイルエラーになります。これにより、継承関係をコンパイル時に厳密に制御でき、パターンマッチとの連携でデータモデリングが強化されます。

- instanceofパターンマッチ & レコード型（プレビュー続投）
  – Java 14でのプレビュー機能だったinstanceofのパターンマッチとレコード型が、それぞれ第2プレビューとして継続提供されました​​。APIに大きな変化はなく、安定化に向けた調整が行われています。

- 隠れクラス（Hidden Classes）
  – フレームワーク向けに、リフレクションAPI経由で動的に定義でき、かつ他から参照されない隠れクラスの仕組みが導入されました​。動的プロキシやバイトコード生成を行うライブラリが、名前衝突や不要なメモリリークを避ける目的で利用できます。

- GCの改良とその他プラットフォーム:
  - 前バージョンまで実験段階だったZGCおよびShenandoah GCが正式にプロダクション利用可能と宣言されました​。また、長年サポートされていたSolaris/SPARCプラットフォームがこのバージョンでサポート終了となりました​（OpenJDKソースから該当コード削除）。

- 削除された機能:
  - Java 8で導入されたNashorn JavaScriptエンジンが完全に削除されました​。また、スレッドの軽量ロック最適化機構であったBiased Lockingがデフォルトで無効化され、将来の削除に向けて非推奨扱いとなりました​。

## Java 16 (2021年3月)

- レコード型の正式導入
  – プレビュー段階だった**レコード（record）**が正式に言語仕様に加わりました​。簡潔な宣言で不変のデータクラスを定義でき、コンストラクタやequalsなどの定型コードを自動生成します。例えば以下のように定義・利用できます:

```java
record Point(int x, int y) { }
Point p = new Point(3, 5);
System.out.println(p.x() + ", " + p.y());  // 出力: 3, 5
```

- instanceofパターンマッチの正式化
  – instanceof+変数定義のパターンマッチ構文がデフォルトで有効になりました​。これにより、前述のif (obj instanceof String s)のような構文が追加オプションなしで使用できます。

- シールドクラス（第二プレビュー）
  – 継承制御機能であるsealedクラス/インターフェースのプレビューが続行されました​（最終的にJava 17で正式化）。

- jpackageツールの正式版
  – Javaアプリケーションをネイティブパッケージ化するjpackageが正式リリースされました​。コマンドラインでJDKバンドルのインストーラを生成できるため、デスクトップアプリ配布が容易になります。

- ベクターAPI（インキュベータ）
  – CPUのSIMD命令を活用した演算をJavaから扱うためのベクターAPIが第1段階のインキュベータとして追加されました​。Vector<Integer>型などを用いて一度に複数データを操作でき、高速な数値計算が可能となるポテンシャルがあります。

- 外部関数APIの強化
  – Javaからネイティブコードを呼び出す外部関数・メモリAPI（Project Panama）が引き続き開発され、第3段インキュベータ版が提供されました​。JNIを使わずにC関数を呼び出す手段として期待される機能です。

- メタスペースのメモリ効率化
  – クラスメタデータ領域であるMetaspaceの割り当てを動的に縮小しやすくするElastic Metaspaceが実装されました​。不要になったクラス領域を素早く開放することで、アプリケーションのメモリ使用量ピークを低く保てます。

- ZGCの性能改善
  – ZGCにおいて並行スレッドスタック処理（非停止でスタックスキャンを行う技術）が導入され、さらなるGC低遅延化・スループット向上が図られました​。

- 互換性の変更:
  - Java内部APIへの違法アクセスがデフォルトで遮断されました（--illegal-access=permitが削除）​。これにより、モジュール境界を破るリフレクションアクセスは許可されなくなり、以前のコードは動作に修正が必要です。また、Java 9で導入された実験的AOTコンパイルとGraal JITコンパイラの試験実装が、本リリースでJDKから完全に削除されました​。

- 新プラットフォーム対応:
  - Windows版JavaがARM64(AArch64)に公式対応しました​。加えてAlpine Linux（musl libc環境）への対応も進み、コンテナ環境などより軽量なJava実行が可能になっています​。

## Java 17 (2021年9月, LTS)

- シールドクラスの正式導入
  – 継承制限機能であるsealedクラス/インターフェースが正式リリースされました​。sealedクラスはpermits句で列挙したサブクラスしか継承できず、それ以外はコンパイルエラーとなります。継承関係をコンパイルタイムに固定できるため、パターンマッチやAPI設計で意図しないサブクラスを排除できます。

```java
public abstract sealed class Shape permits Circle, Rectangle {}
public final class Circle extends Shape { /* ... */ }
public non-sealed class Rectangle extends Shape { /* ... */ }
// Shapeを継承できるのはCircleとRectangleのみ
```

- switchパターンマッチ（プレビュー）
  – switch文/式で型に応じた分岐やガード（追加条件付き分岐）が可能になるパターンマッチ機能がプレビュー追加されました​。例えばcase String s -> ...やcase Integer i && i > 0 -> ...のように記述し、入力オブジェクトの型や属性に応じた処理を分岐させることができます​。

- ベクターAPI・外部関数API（継続）
  – ベクターAPIは第2段のインキュベータ版、外部関数・メモリAPIは引き続きインキュベータ版として提供されました​。いずれも将来の正式化に向けての改良が続けられています。

- セキュリティマネージャの非推奨
  – 長年Javaのセキュリティ機構だったSecurityManagerが**非推奨(Deprecate for Removal)**となりました​。標準では無効化され、将来的に完全削除が予定されています​。これに伴い、代替となるモジュールシステムやポリシー管理への移行が推奨されます。

- レガシー機能の削除:
  - RMIのアクティベーション機能が削除されました​（分散オブジェクトの旧来機能で、近年は非推奨）。またJava 16で無効化された実験的AOT/JIT（Graal）コンパイラのコードがJDKから除去されています​。

- 新プラットフォーム対応:
  - Apple Silicon搭載Mac（macOS/AArch64）への正式対応が行われました​。これにより、従来Rosetta変換が必要だったMacでもネイティブにJavaが動作します。

- その他の改善:
  - StrictFPモードの恒常化 
    – 浮動小数点演算において常にstrictfpが適用されるようになり、strictfp指定子自体がほぼ意味を持たなくなりました​（JEP 306）。また、疑似乱数のジェネレータが拡張され、新しいアルゴリズムやスプラウト可能なPRNGが追加されています​。

## Java 18 (2022年3月)

- デフォルト文字エンコーディングのUTF-8統一
  – プラットフォームに依存せずJavaのデフォルト文字セットがUTF-8になりました​。これにより、ファイル読み書きや文字列のバイト変換における挙動がOS問わず一貫し、文字化けや差異が減少します。

- シンプルなWebサーバの追加
  – 開発・テスト用途向けに、コマンド一発で静的ファイルを配信できる組み込みWebサーバが追加されました​。jwebserverコマンドを実行するとカレントディレクトリをルートとするHTTPサーバが起動し、簡易な検証やSPAのホスティングに利用できます。

- コードスニペット(JavaDoc)
  – JavaDocに埋め込みコード例を記述するための\{@snippet\}タグが導入されました​。これにより、サンプルコードをサニタイズした上でドキュメントに組み込め、APIドキュメントの実用性が向上します。

- リフレクション実装の刷新
  – java.lang.reflectが内部的にメソッドハンドルを利用する実装に置き換えられました​。これによりリフレクション呼び出しのパフォーマンスが向上し、一貫性のあるメンテナンスが期待できます（機能的な違いはありません）。

- パターンマッチ強化（プレビュー続行）:
  - switchのパターンマッチ第2プレビューが提供されました​（17でのプレビューからの続き）。特に大きな文法変更はなく、安定化の段階です。

- インキュベータ/プレビュー継続: 
  - ベクターAPI第3インキュベータ版​、外部関数&メモリAPI第2インキュベータ版​が引き続き提供され、フィードバックを反映しつつ改良が進められました。これらは将来の正式リリースを見据えた段階です。

- finalizeの廃止予定
  – オブジェクト破棄時のfinalize()メソッドが**非推奨（将来の削除予定）**となりました​。これに伴い、終了処理にはCleanerやtry-with-resourcesの活用が推奨されます。

## Java 19 (2022年9月)

- 仮想スレッド（プレビュー）
  – Project Loomによる軽量スレッド機構がプレビュー段階で登場しました​。Thread.startVirtualThread(...)により数百万単位のスレッド生成が可能となり、スレッドあたり数KBのスタックで大規模並行処理が実現できます。従来のOSスレッドに比べコンテキストスイッチ負荷が低く、高スループットなサーバー実装が期待できます。

- レコードパターン（プレビュー）
  – レコード型の内部を直接分解して変数にバインドするレコードパターンが導入されました​。たとえばif (obj instanceof Point(int x, int y))と記述すると、Pointレコードからx,yフィールドを直接取り出して利用できます。ネストしたレコードも再帰的にマッチ可能で、パターンマッチの表現力が大きく向上します。

- switchのパターンマッチ（プレビュー第3弾）
  – switchでのパターンマッチ機能がさらに磨かれ、第3プレビューとして提供されました​。レコードパターンとの組み合わせやnullケースの扱いなど、言語パターンマッチ統合に向けた最終段階の調整が行われています。

- 構造化並行処理API（インキュベータ）
  – Structured Concurrencyがインキュベータ版で追加されました​。StructuredTaskScopeを用いて並列タスクをグループ化し、一括管理・キャンセルが可能です。複数の子スレッドを持つタスクの例外伝播や終了待ちを簡潔に記述でき、特に仮想スレッド環境下での正確なタスク管理に寄与します。

- 外部関数・メモリAPI（プレビュー）
  – 長らくインキュベータ段階だった外部関数呼び出しAPIが、このバージョンで正式プレビューに昇格しました​。JNIに代わる安全で高性能なネイティブインターフェースとして、実用段階に近づいています。

- その他の継続的強化:
  - ベクターAPIは第4インキュベータに入り​、RISC-V 64bitアーキテクチャ（Linux）の公式サポートが追加されました​。これによりIoT/組込向けのプラットフォーム展開も視野に入っています。

## Java 20 (2023年3月)

- 仮想スレッド（プレビュー第2弾）
  – Project Loomの仮想スレッドが前版から引き続きプレビュー提供されました​。機能自体はJava 19から大きな変更はなく、本リリースでもデフォルトで無効（--enable-previewで有効化）となっています。

- パターンマッチ機能のプレビュー継続
  – レコードパターン（第2プレビュー）とswitchのパターンマッチ（第4プレビュー）がさらに改善されつつ継続提供されました​。主に細部の調整と不具合修正が中心で、言語仕様として安定化に近づいています。

- 構造化並行処理 & Scoped Values（継続）
  – Structured Concurrencyは第2インキュベータ、スレッド間で不変データを共有するScoped Values機能は第1インキュベータとして、それぞれ引き続き提供されました​。いずれもLoom関連機能であり、大規模並行処理の安全性・保守性を高めるためのAPIです。

- 外部関数API & ベクターAPI（プレビュー/インキュベータ）
  – 外部関数・メモリAPIは第2プレビュー、ベクターAPIは第5インキュベータ版がリリースされました​。前者は機能完成に向けたAPI磨き込みフェーズであり、後者も対応プラットフォームの拡充やAPI整備が進んでいます。(Java 20では新規の正式機能は追加されず、前バージョンからのプレビュー/実験的機能のブラッシュアップが中心となりました​。)

## Java 21 (2023年9月, LTS)

- 仮想スレッドの正式導入
  – プレビュー段階だった仮想スレッドが正式機能となり、JVM上で数多くの軽量スレッドを扱えるようになりました​。これにより、従来スレッドあたり数MB消費していたスタックを大幅に削減し、高並行なサーバーアプリケーションでもスレッド利用が現実的になります。例えば次のように仮想スレッドを開始できます:

```java
Thread.startVirtualThread(() -> {
    // 仮想スレッド内で実行されるタスク
    System.out.println("Hello from virtual thread");
});
```

- パターンマッチの正式化
  – 言語パターンマッチ機能が一気に充実し、レコードパターンおよびswitchのパターンマッチが最終的に正式リリースされました​。これにより、instanceofやswitchで型や内容に応じたマッチングを簡潔に記述でき、データ主導のロジックを安全に実装できます。レコードとsealedクラス、パターンマッチを組み合わせることで、分類不能なケースをコンパイル時に排除し、冗長なキャストやチェックを省略可能です。

- 順序付きコレクションAPIの追加
  – Sequenced Collectionインターフェースが導入され、List・Set・Mapに順序に統一的にアクセスするメソッドが追加されました​。例えばSequencedSetは挿入順やアクセス順のいずれかの順序を持ち、first()/last()やreversed()といったメソッドで要素の順序操作が容易に行えます。これにより、これまで実装毎に異なっていた順序付きコレクションの扱いが統一的になりました。

- 文字列テンプレート（プレビュー）
  – 他言語でいうテンプレートリテラルに相当する文字列テンプレート機能がプレビュー提供されました​。STR."""Hello, \{name}!"""のような構文で文字列中に式を埋め込み、実行時に展開できます。文字列連結のボイラープレートを削減し、SQLクエリなどの生成時にプレースホルダと値の対応を明確に記述できるようになります。

- 匿名クラス・インスタンスMainの簡略記法（プレビュー）
  – 学習用などにクラス宣言やpublic static void mainを省略できる機能がプレビュー追加されました​。ソースファイル先頭にクラス宣言なしでメソッドを書くと、自動的にクラスに包まれる仕組みです​。例えばファイルに直接void main() { ... }と書くだけで実行可能になり、簡単なスクリプトや学習用途でのボイラープレートが大幅に削減されます。

- Scoped Values（プレビュー）
  – スレッドローカル変数の進化形であるScoped Values機能がプレビュー公開されました​。不変データを一連の子スレッドに受け渡す仕組みで、ThreadLocalよりも安全かつ効率的にスレッド間のコンテキスト共有ができます。特に仮想スレッド環境で大量のスレッド間設定を扱う際のオーバーヘッド削減や明確なスコープ管理に寄与します。

- ZGCの世代別GC対応
  – ZGCにGenerational ZGCが導入され、若いオブジェクトと老年オブジェクトで世代分けする世代別GCアルゴリズムが試験的に実装されました​。これにより短命オブジェクトのリサイクル効率が上がり、ZGCのスループットが向上します。低遅延と高スループットの両立に向けた重要なステップです。

- セキュリティAPIの拡張:
  - ポスト量子暗号などに備え、**鍵カプセル化メカニズム(KEM)**を扱うAPIが新設されました​。公開鍵で共有秘密情報を安全に生成・交換する仕組みで、Javaにおける最新暗号プロトコル実装が容易になります。

- 非推奨の機能: 
  - Windows向けの32bit版Javaが非推奨となり、将来のリリースでサポートが外れる予定です​。また、エージェント（javaagent）を実行中に動的に読み込む操作が将来禁止される見込みであり、その準備としてJDK内部での扱いが見直されています​。

## Java 22 (2024年3月)

- 外部関数・メモリAPIの正式化
  – 長らく開発が続いていたForeign Function & Memory APIがついに正式リリースされました​。これにより、Javaからネイティブライブラリ関数を直接呼び出したり、オフヒープメモリを操作したりできる安全なAPIが提供されます。JNIと比べシンプルかつ高性能で、Cとのインターフェースが大幅に容易になります。

- 匿名パターン変数・パターン（正式化） – パターンマッチで使用する使い捨て変数名としてアンダースコア_が正式に使えるようになりました​。これまではプレビュー機能でしたが、Java 22で標準機能化されています。例えばcase Point(var x, _) ->のように記述すると2番目の要素を無視でき、不要な変数宣言を省略できます。あわせて、名前のないレコードパターンrecord _(...)等も導入され、複雑なパターンマッチの記述が簡潔になります。

- 複数ソースファイルの一括実行
  – Java 11で導入された単一ソース実行機能が拡張され、複数のJavaソースファイルをまとめて実行できるようになりました​。java Foo.java Bar.javaのようにスペース区切りで複数ファイルを指定可能で、スクリプト的な小規模プログラムをプロジェクト構成なしで実行できます​。ビルド不要で素早く動作確認したい場合に便利です。

- コンストラクタでのsuper前処理（プレビュー）
  – コンストラクタにおいてsuper(...);呼び出しより前に、インスタンスに依存しない任意の文を実行できるようになるプレビュー機能が追加されました​。これにより、コンストラクタ引数の検証ロジックなどをsuper呼び出し前に配置可能です（ただしフィールドやthisに触れることは不可）​。従来は制限されていたコンストラクタ先頭での柔軟な初期化処理が可能になります。

- Stream Gatherers（プレビュー）
  – Stream APIにユーザ定義のカスタム中間操作を組み込める新機能Stream::gatherがプレビュー追加されました​。Gathererインターフェースを実装して初期化・要素取り込み・並列結合・完了処理の4つを定義することで、標準のmapやfilterでは表現しにくい独自の集約処理をストリームパイプライン内に組み込めます。これにより、複雑な集計ロジックもストリームの文脈で簡潔に記述でき、可読性と性能の両立が期待できます。

- クラスファイルAPI（プレビュー）
  – Javaプラットフォームにおいて、バイトコードの解析・生成を行う標準のクラスファイルAPIがプレビュー提供されました​。これまで外部ライブラリ（ASMなど）に頼っていたクラスファイル操作を公式APIで扱えるようになり、将来のバイトコード拡張にも追随した保守が可能となります。

- 継続中のプレビュー/実験的機能:
  - 文字列テンプレートは第2プレビューとして引き続き提供されます​。構造化並行処理APIは第2プレビュー、暗黙クラス&インスタンスmainメソッドは第2プレビューへとそれぞれアップデートされました​。Scoped Valuesは第2プレビュー版となり、APIに大きな変更はなく追加フィードバックを募る段階です​。また、ベクターAPIは第7回目のインキュベータが提供され、性能と安定性のさらなる改善が図られています​。

- ガベージコレクションの改善:
  - G1 GCにおいて、JNI経由で確保されたメモリ領域をGC中に解放せず「ピン止め」するリージョンピンニングが実装されました​。これにより、JNI呼び出し中にGCを実行しても該当領域を避けて処理でき、GC待ちによるレイテンシが低減します。

各バージョンで登場したこれらの新機能・改善点により、Javaはモダンな開発要求に適応し続けています。業務アプリケーション開発者にとっては、ラムダ式やStream APIによる生産性向上​、モジュールシステムによるセキュアなアプリケーション構築​、新しいHTTPクライアントや並行処理機能の強化​など、バージョンアップによる恩恵は大きなものがあります。特にLTS版へのアップグレード時には、上記のような重要ポイントを中心に、自プロジェクトで活用できる機能や影響を精査すると良いでしょう。

---

## 早見欄

業務で使う変化点機能は以下。

### Java 8（2014年）

- ラムダ式 / Stream API
　→ コレクション処理の簡潔化・可読性向上

### Optional
　→ nullチェックの代替でNullPointerException防止

###java.timeパッケージ（新日時API）
　→ LocalDate/ZonedDateTimeなどが業務処理に便利

### Java 9（2017年）

- モジュールシステム（業務では未導入な場合も多い）
- List.of() / Set.of() / Map.of()
　→ 定数リスト・マップの簡潔な記述に有用

### Java 10（2018年）

- varによるローカル変数型推論
　→ Javaらしさを保ちつつ、冗長な型名を省略

### Java 11（2018年、LTS）

- 新しいHttpClient
　→ REST APIの呼び出し処理を標準ライブラリで統一化

- Stringメソッド強化（isBlank(), lines(), strip(), repeat()）
　→ 文字列前処理や分割の業務処理で活躍

### Java 14（2020年）

- instanceofのパターンマッチ（プレビュー→後に正式）
　→ 型チェック+キャストを一文で実現し、安全・簡潔

### Java 16（2021年）

- レコード型（正式）
　→ DTOや値オブジェクトの定義を劇的に簡潔化
　→ record User(String name, int age) {}

### Java 17（2021年、LTS）

- シールドクラス（sealed classes）
　→ 設計レベルでの継承制御・ドメインモデルの明確化

### Java 19〜21（Loom関連）

- 仮想スレッド（Java 21で正式）
　→ 高負荷Webアプリなどで、スレッド管理のコスト削減
　→ Thread.startVirtualThread(() -> { ... })

### Java 21（2023年、LTS）

- 文字列テンプレート（プレビュー）
　→ "Hello, \{name}" のような埋め込み表現で可読性UP

- 順序付きコレクション（Sequenced Collection）
　→ first()/last()など業務データの順序処理に有用

### Java 22（2024年）

- 外部関数・メモリアクセスAPIの正式化
　→ JNIを使わずにCライブラリと連携（高度な業務向け）

- Stream Gatherers（プレビュー）
　→ 複雑な中間集約処理を簡潔に（ログや履歴処理など）
